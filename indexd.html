<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
        var createScene = function () {
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);
            //const xr = scene.createDefaultXRExperienceAsync();


            //   // This creates and positions a free camera (non-mesh)
            //     var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);

            //     // This targets the camera to scene origin
            //     camera.setTarget(BABYLON.Vector3.Zero());

            var camera = new BABYLON.ArcRotateCamera("camera", BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(65), 60, BABYLON.Vector3.Zero(), scene);
              // const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 150, new BABYLON.Vector3(0, 60, 0));
                  camera.setTarget(BABYLON.Vector3.Zero());
              camera.upperBetaLimit = Math.PI / 2.2;
          
              camera.attachControl(canvas, true);



            // //创建跟随相机
            // const camera2 = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 0, 0), scene);


            // //设置偏移高度
            // camera2.heightOffset = 8;
            // //设置半径
            // camera2.radius = 1;
            // //设置偏移角度
            // camera2.rotationOffset = 0;
            // //从当前位置移动到目标位置的加速度；
            // camera2.cameraAcceleration = 0.005
            // //加速停止的速度
            // camera2.maxCameraSpeed = 10
            // //将相机附加到画布上
            // camera2.attachControl(canvas, true);
            // //设置目标
            // camera2.lockedTarget = dube;

            // camera2.attachControl(canvas, true);



            // // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            // var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // // Default intensity is 1. Let's dim the light a small amount
            // light.intensity = 0.1;

              const  light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0, -1, 1), scene);
             light.position = new BABYLON.Vector3(0, 15, -30);
             light.intensity = 0.5;

              // Shadow generator
             const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);



            // Shadow generator
           //const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);

            // Our built-in 'ground' shape.
            var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 15, height: 15 }, scene);
            let groundMaterial = new BABYLON.StandardMaterial("Ground Material", scene);
            ground.material = groundMaterial;
              ground.receiveShadows = true;
            //ground.material.diffuseColor = BABYLON.Color3.Red();
            //let groundTexture = new BABYLON.Texture(Assets.textures.checkerboard_basecolor_png.rootUrl, scene);
            let groundTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png");
            ground.material.diffuseTexture = groundTexture;

            BABYLON.SceneLoader.ImportMesh("", Assets.meshes.Yeti.rootUrl, Assets.meshes.Yeti.filename, scene, function (newMeshes) {
                newMeshes[0].scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
                newMeshes[0].position = new BABYLON.Vector3(-1, 0, 3);
                newMeshes[0].rotation = new BABYLON.Vector3(0, Math.PI / 12, 0);
                newMeshes[0].movePOV(0, 0, 6);
            });



            //BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "box.babylon");

            //    BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "both_houses_scene.babylon").then((result) => {
            //    console.log(result);
            //    const house1 = scene.getMeshByName("detached_house");
            //     house1.position.z = 3;
            //    const house2 = result.meshes[2];
            //    house2.position.z = 3;
            //   });

            //    BABYLON.SceneLoader.ImportMeshAsync(["", "semi_house"], "https://assets.babylonjs.com/meshes/", "both_houses_scene.babylon");

            // Load the sound, give it time to load and play it every 3 seconds
            // const bounce = new BABYLON.Sound("bounce", "sounds/bounce.wav", scene);
            //setInterval(() => bounce.play(), 3000);




            /**** Materials *****/
            const roofMat = new BABYLON.StandardMaterial("roofMat");
            roofMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg", scene);


            const boxMat = new BABYLON.StandardMaterial("boxMat");
            //boxMat.wireframe = true;
            //boxMat.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png");
            boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/cubehouse.png")



            const roofMat2 = new BABYLON.StandardMaterial("roofMat2");
            roofMat2.diffuseColor = new BABYLON.Color3.Blue();


            const roofMat3 = new BABYLON.StandardMaterial("roofMat2");
            roofMat3.diffuseColor = new BABYLON.Color3(0, 1, 0);


            //options parameter to set different images on each side
            const faceUV = [];
            faceUV[0] = new BABYLON.Vector4(0.5, 0.0, 0.75, 1.0); //rear face
            faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.25, 1.0); //front face
            faceUV[2] = new BABYLON.Vector4(0.25, 0, 0.5, 1.0); //right side
            faceUV[3] = new BABYLON.Vector4(0.75, 0, 1.0, 1.0); //left side
            // top 4 and bottom 5 not seen so not set

            /**** World Objects *****/
            var box1 = BABYLON.MeshBuilder.CreateBox("box1", { faceUV: faceUV, wrap: true });
            box1.position.y = 0.5;
            box1.rotation.y = Math.PI / 4;
            //box1.rotation.y = BABYLON.Tools.ToRadians(45);
            box1.material = boxMat;

            const box2 = BABYLON.MeshBuilder.CreateBox("box2", {});
            // box2.scaling.x = 2;
            // box2.scaling.y = 1.5;
            // box2.scaling.z = 3;
            box2.position = new BABYLON.Vector3(-3, 0.5, 0);
            box2.rotation.y = Math.PI / 4;

            const box3 = BABYLON.MeshBuilder.CreateBox("box3", {});
            //box3.scaling = new BABYLON.Vector3(2, 1.5, 3);
            box3.position.x = 3;
            box3.position.y = 0.5;
            box3.position.z = 0;
            box3.rotation.y = Math.PI / 4;


            const roof = BABYLON.MeshBuilder.CreateCylinder("roof", { diameter: 1.3, height: 1.2, tessellation: 3 });
            roof.position.y = 1.2;
            roof.scaling.x = 0.75;
            roof.rotation.z = Math.PI / 2;
            roof.rotation.y = Math.PI / 4;

            roof.material = roofMat;


            const roof2 = BABYLON.MeshBuilder.CreateCylinder("roof", { diameter: 1.3, height: 1.2, tessellation: 3 });
            roof2.position = new BABYLON.Vector3(-3, 1.2, 0);
            roof2.scaling.x = 0.75;
            roof2.rotation.z = Math.PI / 2;
            roof2.rotation.y = Math.PI / 4;
            roof2.material = roofMat2;


            const roof3 = BABYLON.MeshBuilder.CreateCylinder("roof", { diameter: 1.3, height: 1.2, tessellation: 3 });
            roof3.position = new BABYLON.Vector3(3, 1.2, 0);
            roof3.scaling.x = 0.75;
            roof3.rotation.z = Math.PI / 2;
            roof3.rotation.y = Math.PI / 4;

            roof3.material = roofMat3;



            //----------------kaishi




            const buildBox = () => {
                const boxMatm = new BABYLON.StandardMaterial("boxMat");
                boxMatm.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/semihouse.png")


                //options parameter to set different images on each side
                const faceUVm = [];
                faceUVm[0] = new BABYLON.Vector4(0.6, 0.0, 1.0, 1.0); //rear face
                faceUVm[1] = new BABYLON.Vector4(0.0, 0.0, 0.4, 1.0); //front face
                faceUVm[2] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //right side
                faceUVm[3] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //left side
                // top 4 and bottom 5 not seen so not set


                /**** World Objects *****/
                const boxm = BABYLON.MeshBuilder.CreateBox("boxm", { width: 2, faceUV: faceUVm, wrap: true });
                boxm.material = boxMatm;
                boxm.position.y = 0.5;
                boxm.position.z = -5;

                return boxm;
            }


            const buildRoof = () => {
                //texture
                const roofMatm = new BABYLON.StandardMaterial("roofMat");
                roofMatm.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg");



                const roofm = BABYLON.MeshBuilder.CreateCylinder("roofm", { diameter: 1.3, height: 1.2, tessellation: 3 });
                roofm.material = roofMatm;
                roofm.scaling.x = 0.75;
                roofm.scaling.y = 2;
                roofm.rotation.z = Math.PI / 2;
                roofm.position.y = 1.22;
                roofm.position.z = -5;

                return roofm;

            }

            //    const detached_house = buildHouse(1);
            //     detached_house.rotation.y = -Math.PI / 16;
            //     detached_house.position.x = -6.8;
            //     detached_house.position.z = 2.5;

            //     const semi_house = buildHouse(2);
            //     semi_house .rotation.y = -Math.PI / 16;
            //     semi_house.position.x = -4.5;
            //     semi_house.position.z = 3;

            //     const places = []; //each entry is an array [house type, rotation, x, z]
            //     places.push([1, -Math.PI / 16, -6.8, 2.5 ]);
            //     places.push([2, -Math.PI / 16, -4.5, 3 ]);
            //     places.push([2, -Math.PI / 16, -1.5, 4 ]);
            //     places.push([2, -Math.PI / 3, 1.5, 6 ]);
            //     places.push([2, 15 * Math.PI / 16, -6.4, -1.5 ]);
            //     places.push([1, 15 * Math.PI / 16, -4.1, -1 ]);
            //     places.push([2, 15 * Math.PI / 16, -2.1, -0.5 ]);
            //     places.push([1, 5 * Math.PI / 4, 0, -1 ]);
            //     places.push([1, Math.PI + Math.PI / 2.5, 0.5, -3 ]);
            //     places.push([2, Math.PI + Math.PI / 2.1, 0.75, -5 ]);
            //     places.push([1, Math.PI + Math.PI / 2.25, 0.75, -7 ]);
            //     places.push([2, Math.PI / 1.9, 4.75, -1 ]);
            //     places.push([1, Math.PI / 1.95, 4.5, -3 ]);
            //     places.push([2, Math.PI / 1.9, 4.75, -5 ]);
            //     places.push([1, Math.PI / 1.9, 4.75, -7 ]);
            //     places.push([2, -Math.PI / 3, 5.25, 2 ]);
            //     places.push([1, -Math.PI / 3, 6, 4 ]);

            //     //Create instances from the first two that were built 
            //     const houses = [];
            //     for (let i = 0; i < places.length; i++) {
            //         if (places[i][0] === 1) {
            //             houses[i] = detached_house.createInstance("house" + i);
            //         }
            //         else {
            //             houses[i] = semi_house.createInstance("house" + i);
            //         }
            //         houses[i].rotation.y = places[i][1];
            //         houses[i].position.x = places[i][2];
            //         houses[i].position.z = places[i][3];
            //     }



            BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "car.babylon").then(() => {
                //car animatiion
                var car = scene.getMeshByName("car");
                car.position = new BABYLON.Vector3(1, 0.5, 2)
                car.scaling = new BABYLON.Vector3(2, 2, 2);



                const animCar = new BABYLON.Animation("carAnimation", "position.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

                const carKeys = [];

                carKeys.push({
                    frame: 0,
                    value: -4
                });


                carKeys.push({
                    frame: 150,
                    value: 4
                });

                animCar.setKeys(carKeys);

                car.animations = [];
                car.animations.push(animCar);

                scene.beginAnimation(car, 0, 150, true);

                //wheel animation
                const wheelRB = scene.getMeshByName("wheelRB");
                const wheelRF = scene.getMeshByName("wheelRF");
                const wheelLB = scene.getMeshByName("wheelLB");
                const wheelLF = scene.getMeshByName("wheelLF");

                scene.beginAnimation(wheelRB, 0, 30, true);
                scene.beginAnimation(wheelRF, 0, 30, true);
                scene.beginAnimation(wheelLB, 0, 30, true);
                scene.beginAnimation(wheelLF, 0, 30, true);
            });



            // Dude
            // BABYLON.SceneLoader.ImportMeshAsync("him", "/scenes/Dude/", "Dude.babylon", scene).then((result) => {
            //     var dude = result.meshes[0];
            //      //dube.position = new BABYLON.Vector3(1, 0.5, -1)
            //      dude.scaling = new BABYLON.Vector3(0.03, 0.03, 0.03);
            //      //dube.rotation.x = -Math.PI / 2;

            //     scene.beginAnimation(result.skeletons[0], 0, 100, true, 1.0);



            // //const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 0.25});
            // // sphere.position = new BABYLON.Vector3(2, 0, 2);

            // //draw lines to form a triangle
            // const points = [];
            // points.push(new BABYLON.Vector3(2, 0, 2));
            // points.push(new BABYLON.Vector3(2, 0, -2));
            // points.push(new BABYLON.Vector3(-2, 0, -2));
            // points.push(points[0]); //close the triangle;

            // BABYLON.MeshBuilder.CreateLines("triangle", {points: points})

            // const slide = function (turn, dist) { //after covering dist apply turn
            //     this.turn = turn;
            //     this.dist = dist;
            // }

            // const track = [];
            // track.push(new slide(Math.PI / 2, 4));
            // track.push(new slide(3 * Math.PI / 4, 8));
            // track.push(new slide(3 * Math.PI / 4, 8 + 4 * Math.sqrt(2)));

            // let distance = 0;
            // let step = 0.05;
            // let p = 0;

            // scene.onBeforeRenderObservable.add(() => {
            // 	dude.movePOV(0, 0, step);
            //     distance += step;

            //     if (distance > track[p].dist) {        
            //         dude.rotate(BABYLON.Axis.Y, track[p].turn, BABYLON.Space.LOCAL);
            //         //dude.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(-95), BABYLON.Space.LOCAL);
            //         // const startRotation = dude.rotationQuaternion.clone(); //use clone so that 
            //         p +=1;
            //         p %= track.length;
            //         if (p === 0) {
            //             distance = 0;
            //              dude.position = new BABYLON.Vector3(2, 0, 2); //reset to initial conditions
            //              dude.rotation = BABYLON.Vector3.Zero();//prevents error accumulation

            //             //dude.rotationQuaternion = startRotation.clone();
            //         }
            //     }
            // });

            // });




            //-----------------------------

            const walk = function (turn, dist) {
                this.turn = turn;
                this.dist = dist;
            }

            const track = [];
            track.push(new walk(86, 7));
            track.push(new walk(-85, 14.8));
            track.push(new walk(-93, 16.5));
            track.push(new walk(48, 25.5));
            track.push(new walk(-112, 30.5));
            track.push(new walk(-72, 33.2));
            track.push(new walk(42, 37.5));
            track.push(new walk(-98, 45.2));
            track.push(new walk(0, 47))

            let carReady = false;
            // Dude
            BABYLON.SceneLoader.ImportMeshAsync("him", "/scenes/", "Dude.babylon", scene).then((result) => {

                carReady = true;
                dude = result.meshes[0];
                dude.scaling = new BABYLON.Vector3(0.008, 0.008, 0.008);
                dude.position = new BABYLON.Vector3(-6, 0, 0);
                dude.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(-95), BABYLON.Space.LOCAL);
                 //add dude, true means add children as well
                shadowGenerator.addShadowCaster(dude, true);
                
                const startRotation = dude.rotationQuaternion.clone();
                   //camera.parent = dude;

                scene.beginAnimation(result.skeletons[0], 0, 100, true, 1.0);

                let distance = 0;
                let step = 0.015;
                let p = 0;

                scene.onBeforeRenderObservable.add(() => {

                    if (carReady) {
                        if (!dude.getChildren()[1].intersectsMesh(box1) && scene.getMeshByName("car").intersectsMesh(box1)) {
                            return;
                        }

                    }
                    dude.movePOV(0, 0, step);
                    distance += step;

                    if (distance > track[p].dist) {

                        dude.rotate(BABYLON.Axis.Y, BABYLON.Tools.ToRadians(track[p].turn), BABYLON.Space.LOCAL);
                        p += 1;
                        p %= track.length;
                        if (p === 0) {
                            distance = 0;
                            dude.position = new BABYLON.Vector3(-6, 0, 0);
                            dude.rotationQuaternion = startRotation.clone();
                        }
                    }

                })
            });


            // const car = buildCar();
            // car.position = new BABYLON.Vector3(1, 0.5, 3)
            // car.scaling = new BABYLON.Vector3(2, 2, 2);
            // car.rotation.x = -Math.PI / 2;


            //Animate the Wheels
            // const animWheel = new BABYLON.Animation("wheelAnimation", "rotation.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            // const wheelKeys = []; 

            // //At the animation key 0, the value of rotation.y is 0
            // wheelKeys.push({
            //     frame: 0,
            //     value: 0
            // });

            // //At the animation key 30, (after 1 sec since animation fps = 30) the value of rotation.y is 2PI for a complete rotation
            // wheelKeys.push({
            //     frame: 30,
            //     value: 2 * Math.PI
            // });

            // //set the keys
            // animWheel.setKeys(wheelKeys);

            // //Link this animation to a wheel
            // wheelRB.animations = [];
            // wheelRB.animations.push(animWheel);

            // scene.beginAnimation(wheelRB, 0, 30, true);
            //scene.beginAnimation(wheelRF, 0, 30, true);
            // scene.beginAnimation(wheelLB, 0, 30, true);
            // scene.beginAnimation(wheelLF, 0, 30, true);




            //Create large ground for valley environment

           const largeGroundMat = new BABYLON.StandardMaterial("largeGroundMat");
          largeGroundMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/valleygrass.png");

            const largeGround = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", "https://assets.babylonjs.com/environments/villageheightmap.png", { width: 150, height: 150, subdivisions: 20, minHeight: 0, maxHeight: 10 });
            largeGround.position.y = -0.01;
            largeGround.material = largeGroundMat;


    const spriteManagerUFO = new BABYLON.SpriteManager("UFOManager","https://assets.babylonjs.com/environments/ufo.png", 1, {width: 128, height: 76});
    const ufo = new BABYLON.Sprite("ufo", spriteManagerUFO);
    ufo.playAnimation(0, 16, true, 125);
    ufo.position.y = 5;
    ufo.position.z = 20;
    ufo.width = 2;
    ufo.height = 1;


       const spriteManagerTrees = new BABYLON.SpriteManager("treesManager", "textures/palm.png", 2000, {width: 512, height: 1024}, scene);

    //We create trees at random positions
    for (let i = 0; i < 500; i++) {
        const tree = new BABYLON.Sprite("tree", spriteManagerTrees);
        tree.position.x = Math.random() * (-30);
        tree.position.z = Math.random() * 20 + 8;
        tree.position.y = 0.5;
    }

    for (let i = 0; i < 500; i++) {
        const tree = new BABYLON.Sprite("tree", spriteManagerTrees);
        tree.position.x = Math.random() * (25) + 7;
        tree.position.z = Math.random() * -35  + 8;
        tree.position.y = 0.5;
    }
    
    //Skybox
    const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:150}, scene);
	  const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
	  skyboxMaterial.backFaceCulling = false;
	  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("textures/skybox", scene);
	  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
	  skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
	  skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
	  skybox.material = skyboxMaterial;





	const fountainProfile = [
		new BABYLON.Vector3(0, 0, 0),
		new BABYLON.Vector3(10, 0, 0),
        new BABYLON.Vector3(10, 4, 0),
		new BABYLON.Vector3(8, 4, 0),
        new BABYLON.Vector3(8, 1, 0),
        new BABYLON.Vector3(1, 2, 0),
		new BABYLON.Vector3(1, 15, 0),
		new BABYLON.Vector3(3, 17, 0)
	];
	

       //Switch fountain on and off
    let switched = false;
    const pointerDown = (mesh) => {
        if (mesh === fountain) {
            switched = !switched;
            if(switched) {
                // Start the particle system
                particleSystem.start();
            }
            else {
                // Stop the particle system
                particleSystem.stop();
            }
        }

    }

    scene.onPointerObservable.add((pointerInfo) => {      		
        switch (pointerInfo.type) {
			case BABYLON.PointerEventTypes.POINTERDOWN:
				if(pointerInfo.pickInfo.hit) {
                    pointerDown(pointerInfo.pickInfo.pickedMesh)
                }
				break;
        }
    });
	//Create lathe
	const fountain = BABYLON.MeshBuilder.CreateLathe("fountain", {shape: fountainProfile, sideOrientation: BABYLON.Mesh.DOUBLESIDE}, scene);
	fountain.position = new BABYLON.Vector3(4, 0, 6);
    fountain.scaling = new BABYLON.Vector3(0.05,0.05,0.05);
    

     // Create a particle system
    const particleSystem = new BABYLON.ParticleSystem("particles", 5000);
        // particleSystem.worldOffset = new BABYLON.Vector3(-4, 0.8, -6);
    // // particleSystem.targetStopDuration = 30;  //五秒后粒子效果会停止
    

    // // particleSystem.disposeOnStop = true;  //粒子效果停止后销毁粒子系统

    //Texture of each particle
    particleSystem.particleTexture = new BABYLON.Texture("textures/flare.png");

    // Where the particles come from
    particleSystem.emitter = new BABYLON.Vector3(4, 0.8, 6); // emitted from the top of the fountain
    particleSystem.minEmitBox = new BABYLON.Vector3(-0.01, 0, -0.01); // Starting all from
    particleSystem.maxEmitBox = new BABYLON.Vector3(0.01, 0, 0.01); // To...

    // Colors of all particles
    particleSystem.color1 = new BABYLON.Color4(0.7, 0.8, 1.0, 1.0);
    particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);

    // Size of each particle (random between...
    particleSystem.minSize = 0.01;
    particleSystem.maxSize = 0.05;

    // Life time of each particle (random between...
    particleSystem.minLifeTime = 0.3;
    particleSystem.maxLifeTime = 1.5;

    // Emission rate
    particleSystem.emitRate = 1500;

    // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

    // Set the gravity of all particles
    particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

    // Direction of each particle after it has been emitted
    particleSystem.direction1 = new BABYLON.Vector3(-1, 8, 1);
    particleSystem.direction2 = new BABYLON.Vector3(1, 8, -1);

    // Power and speed
    particleSystem.minEmitPower = 0.2;
    particleSystem.maxEmitPower = 0.6;
    particleSystem.updateSpeed = 0.01;


    

    // Start the particle system
    //particleSystem.start();


        //add a spotlight and later after a mesh lamp post and a bulb have been created
    //then will make the post a parent to the bulb and 
    //the bulb to the parent
    const lampLight = new BABYLON.SpotLight("lampLight", BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, -1, 0), Math.PI, 1, scene);
    lampLight.diffuse = BABYLON.Color3.Yellow();

	//shape to extrude
	const lampShape = [];
    for(let i = 0; i < 20; i++) {
        lampShape.push(new BABYLON.Vector3(Math.cos(i * Math.PI / 10), Math.sin(i * Math.PI / 10), 0));
    }
	lampShape.push(lampShape[0]); //close shape

	//extrusion path
    const lampPath = [];
	lampPath.push(new BABYLON.Vector3(0, 0, 0));
	lampPath.push(new BABYLON.Vector3(0, 10, 0));
    for(let i = 0; i < 20; i++) {
        lampPath.push(new BABYLON.Vector3(1 + Math.cos(Math.PI - i * Math.PI / 40), 10 + Math.sin(Math.PI - i * Math.PI / 40), 0));
    }
    lampPath.push(new BABYLON.Vector3(3, 11, 0));

    const yellowMat = new BABYLON.StandardMaterial("yellowMat");
    yellowMat.emissiveColor = BABYLON.Color3.Yellow();

	//extrude lamp
	const lamp = BABYLON.MeshBuilder.ExtrudeShape("lamp", {cap: BABYLON.Mesh.CAP_END, shape: lampShape, path: lampPath, scale: 0.5});
	
    lamp.position = new BABYLON.Vector3(-5, 0, 4);
    lamp.scaling = new BABYLON.Vector3(0.5,0.5,0.5);
    //add bulb
    const bulb = BABYLON.MeshBuilder.CreateSphere("bulb", {diameterX: 1.5, diameterZ: 0.8});
    
    
    bulb.material = yellowMat;
    bulb.parent = lamp;
    bulb.position.x = 2;
    bulb.position.y = 10.5;

    lampLight.parent = bulb;


    //   BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "lamp.babylon").then(() =>{
    //     const lampLight = new BABYLON.SpotLight("lampLight", BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, -1, 0), 0.8 * Math.PI, 0.01, scene);
    //     lampLight.diffuse = BABYLON.Color3.Yellow();
    //     lampLight.parent = scene.getMeshByName("bulb")

    //     const lamp = scene.getMeshByName("lamp");
    //     lamp.position = new BABYLON.Vector3(2, 0, 2); 
    //     lamp.rotation = BABYLON.Vector3.Zero();
    //     lamp.rotation.y = -Math.PI / 4;

    //     lamp3 = lamp.clone("lamp3");
    //     lamp3.position.z = -8;

    //     lamp1 = lamp.clone("lamp1");
    //     lamp1.position.x = -8;
    //     lamp1.position.z = 1.2;
    //     lamp1.rotation.y = Math.PI / 2;

    //     lamp2 = lamp1.clone("lamp2");
    //     lamp2.position.x = -2.7;
    //     lamp2.position.z = 0.8;
    //     lamp2.rotation.y = -Math.PI / 2;

    // });



    // GUI
    const adt = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    const panel = new BABYLON.GUI.StackPanel();
    panel.width = "220px";
    panel.top = "-65px";
    panel.left = "-25px";
    panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
    panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    adt.addControl(panel);

    const header = new BABYLON.GUI.TextBlock();
    header.text = "Night to Day";
    header.height = "30px";
    header.color = "white";
    panel.addControl(header); 

    const slider = new BABYLON.GUI.Slider();
    slider.minimum = 0;
    slider.maximum = 1;
    slider.borderColor = "black";
    slider.color = "gray";
    slider.background = "white";
    slider.value = 1;
    slider.height = "20px";
    slider.width = "200px";
    slider.onValueChangedObservable.add((value) => {
        if (light) {
            light.intensity = value;
        }
    });
    panel.addControl(slider);





     const box = BABYLON.MeshBuilder.CreateBox("box", {});
    box.position.x = 7;
    box.position.z = -7;
    const frameRate = 6;

    const xSlide = new BABYLON.Animation("xSlide", "position.x", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

    const keyFrames = []; 

    keyFrames.push({
        frame: 0,
        value: 7
    });

    keyFrames.push({
        frame: frameRate,
        value: -7
    });

    keyFrames.push({
        frame: 2 * frameRate,
        value: 7
    });

    xSlide.setKeys(keyFrames);

    box.animations.push(xSlide);

    const myAnim = scene.beginAnimation(box, 0, 2 * frameRate, true);

    setTimeout(() => {myAnim.stop()}, 5000);

    
    /*********performers*********/
	//camera
	var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 3, -30), scene);


    //door
	var door = BABYLON.MeshBuilder.CreateBox("door", {width:2, height:8, depth:0.1}, scene);
    var hinge = BABYLON.MeshBuilder.CreateBox("hinge", {}, scene)
	 hinge.isVisible = false;
    hinge.position.x = 2;
    hinge.position.z = 7;
	door.parent = hinge;
	// hinge.position.y = 2;
  

	//  door.position.x = 2;
    //  door.position.z = 7;

      //light positions
    var sphereLight = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 0.2}, scene);
    sphereLight.material = new BABYLON.StandardMaterial("", scene);
    sphereLight.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
    sphereLight.position.x = 2;
    sphereLight.position.y = 3;
    sphereLight.position.z = 0.1;

    sphereLights = [sphereLight];
    lightPositions = [-2, 3, 6.9]

    for(var i = 0; i < 1; i++) {
        sphereLights.push(sphereLight.clone(""));
        sphereLights[i + 1].position = new BABYLON.Vector3(lightPositions[3*i], lightPositions[3*i + 1], lightPositions[3*i + 2])
    
    var spotLights = [];
    var lightDirections = [-0.5, -0.25, 1, 0, 0, -1]
    for(var i = 0; i < sphereLights.length; i++) {
	    spotLights[i] = new BABYLON.SpotLight("spotlight" + i, sphereLights[i].position, new BABYLON.Vector3(lightDirections[3*i], lightDirections[3*i + 1], lightDirections[3*i + 2]), Math.PI / 8, 5, scene);
	    spotLights[i].diffuse = new BABYLON.Color3(1, 1, 1);
	    spotLights[i].specular = new BABYLON.Color3(0.5, 0.5, 0.5);
	    spotLights[i].intensity = 0;
    }

      /*********animations*************/
	//for camera to sweep round
	var rotate = new BABYLON.Animation("rotate", "rotation.y", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
	
	var rotate_keys = []; 

    rotate_keys.push({
        frame: 0,
        value: 0
    });

    rotate_keys.push({
        frame: 9 * frameRate,
        value: 0
    });

    rotate_keys.push({
        frame: 14 * frameRate,
        value: Math. PI
    });

    rotate.setKeys(rotate_keys);
	
	//for camera move forward
	var movein = new BABYLON.Animation("movein", "position", frameRate, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
	
	var movein_keys = []; 

    movein_keys.push({
        frame: 0,
        value: new BABYLON.Vector3(0, 5, -30)
    });

    movein_keys.push({
        frame: 3 * frameRate,
        value: new BABYLON.Vector3(0, 2, -10)
    });

    movein_keys.push({
        frame: 5 * frameRate,
        value: new BABYLON.Vector3(0, 2, -10)
    });

    movein_keys.push({
        frame: 8 * frameRate,
        value: new BABYLON.Vector3(-2, 2, 3)
    });

    movein.setKeys(movein_keys);

	
	//for door to open and close
	var sweep = new BABYLON.Animation("sweep", "rotation.y", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);

    var sweep_keys = []; 

    sweep_keys.push({
        frame: 0,
        value: 0
    });

    sweep_keys.push({
        frame: 3 * frameRate,
        value: 0
    });

    sweep_keys.push({
        frame: 5 * frameRate,
        value: Math.PI/3
    });

    sweep_keys.push({
        frame: 13 * frameRate,
        value: Math.PI/3
    });

    sweep_keys.push({
        frame: 15 * frameRate,
        value: 0
    });

    sweep.setKeys(sweep_keys);
	
	//for light to brighten and dim
	var lightDimmer = new BABYLON.Animation("dimmer", "intensity", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
	
	var light_keys = []; 

    light_keys.push({
        frame: 0,
        value: 0
    });

    light_keys.push({
        frame: 7 * frameRate,
        value: 0
    });

    light_keys.push({
        frame: 10 * frameRate,
        value: 1
    });

    light_keys.push({
        frame: 14 * frameRate,
        value: 1
    });

    light_keys.push({
        frame: 15 * frameRate,
        value: 0
    });


    lightDimmer.setKeys(light_keys);

    /*******Run Clips**********/

    scene.beginDirectAnimation(camera, [movein, rotate], 0, 25 * frameRate, false);
    scene.beginDirectAnimation(hinge, [sweep], 0, 25 * frameRate, false);
    scene.beginDirectAnimation(spotLights[0], [lightDimmer], 0, 25 * frameRate, false);
    scene.beginDirectAnimation(spotLights[1], [lightDimmer.clone()], 0, 25 * frameRate, false);
	
       /**************Peripherals of Scene***************/
	//var ground = BABYLON.MeshBuilder.CreateGround("ground", {width:50, height:50}, scene);
	
    var wall1 = BABYLON.MeshBuilder.CreateBox("door", {width:8, height:6, depth:0.1}, scene);
	wall1.position.x = -3;
    wall1.position.y = 3;
    wall1.position.z = 7;
    //wall1.scaling = new BABYLON.Vector3(2, 1.5, 3);

    var wall2 = BABYLON.MeshBuilder.CreateBox("door", {width:4, height:6, depth:0.1}, scene);
    wall2.position.x = 5;
    wall2.position.y = 3;
    wall2.position.z = 7;

    var wall3 = BABYLON.MeshBuilder.CreateBox("door", {width:2, height:2, depth:0.1}, scene);
    wall3.position.x = 2;
    wall3.position.y = 5;
    wall3.position.z = 7;

    var wall4 = BABYLON.MeshBuilder.CreateBox("door", {width:14, height:6, depth:0.1}, scene);
    wall4.position.x = 0.1;
    wall4.position.y = 3;
    wall4.position.z = -7;

    var wall5 = BABYLON.MeshBuilder.CreateBox("door", {width:14, height:6, depth:0.1}, scene);
    wall5.rotation.y = Math.PI/2;
    wall5.position.x = -7;
    wall5.position.y = 3;
    wall5.position.z = 0;

    var wall6 = BABYLON.MeshBuilder.CreateBox("door", {width:14, height:6, depth:0.1}, scene);
    wall6.rotation.y = Math.PI/2;
    wall6.position.x = 7;
    wall6.position.y = 3;
    wall6.position.z = 0;

    // var rooft = BABYLON.MeshBuilder.CreateBox("door", {width:14, height:7, depth:0.1}, scene);
    // rooft.rotation.x = Math.PI/2;
    // rooft.position.x = -3;
    // rooft.position.y = 6;
    // rooft.position.z = 3.5;

    }

            return scene;
        };

        const buildCar = () => {

            //base
            const outline = [
                new BABYLON.Vector3(-0.3, 0, -0.1),
                new BABYLON.Vector3(0.2, 0, -0.1),
            ]

            //curved front
            for (let i = 0; i < 20; i++) {
                outline.push(new BABYLON.Vector3(0.2 * Math.cos(i * Math.PI / 40), 0, 0.2 * Math.sin(i * Math.PI / 40) - 0.1));
            }

            //top
            outline.push(new BABYLON.Vector3(0, 0, 0.1));
            outline.push(new BABYLON.Vector3(-0.3, 0, 0.1));

            //back formed automatically

            //car face UVs
            const faceUV = [];
            faceUV[0] = new BABYLON.Vector4(0, 0.5, 0.38, 1);
            faceUV[1] = new BABYLON.Vector4(0, 0, 1, 0.5);
            faceUV[2] = new BABYLON.Vector4(0.38, 1, 0, 0.5);

            //car material
            const carMat = new BABYLON.StandardMaterial("carMat");
            carMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/car.png");

            const car = BABYLON.MeshBuilder.ExtrudePolygon("car", { shape: outline, depth: 0.2, faceUV: faceUV, wrap: true });
            car.material = carMat;

            //wheel face UVs
            const wheelUV = [];
            wheelUV[0] = new BABYLON.Vector4(0, 0, 1, 1);
            wheelUV[1] = new BABYLON.Vector4(0, 0.5, 0, 0.5);
            wheelUV[2] = new BABYLON.Vector4(0, 0, 1, 1);

            //car material
            const wheelMat = new BABYLON.StandardMaterial("wheelMat");
            wheelMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/wheel.png");

            wheelRB = BABYLON.MeshBuilder.CreateCylinder("wheelRB", { diameter: 0.125, height: 0.05, faceUV: wheelUV })
            wheelRB.material = wheelMat;
            wheelRB.parent = car;
            wheelRB.position.z = -0.1;
            wheelRB.position.x = -0.2;
            wheelRB.position.y = 0.035;

            wheelRF = wheelRB.clone("wheelRF");
            wheelRF.position.x = 0.1;

            wheelLB = wheelRB.clone("wheelLB");
            wheelLB.position.y = -0.2 - 0.035;

            wheelLF = wheelRF.clone("wheelLF");
            wheelLF.position.y = -0.2 - 0.035;

            

            return car;
        }


        /******Build Functions***********/
        const buildGround = () => {
            //color
            const groundMat = new BABYLON.StandardMaterial("groundMat");
            groundMat.diffuseColor = new BABYLON.Color3(0, 1, 0);

            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 15, height: 16 });
              ground.receiveShadows = true;
            ground.material = groundMat;
        }

        const buildHouse = (width) => {
            const box = buildBox(width);
            const roof = buildRoof(width);

            return BABYLON.Mesh.MergeMeshes([box, roof], true, false, null, false, true);
        }

        const buildBox = (width) => {
            //texture
            const boxMat = new BABYLON.StandardMaterial("boxMat");
            if (width == 2) {
                boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/semihouse.png")
            }
            else {
                boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/cubehouse.png");
            }

            //options parameter to set different images on each side
            const faceUV = [];
            if (width == 2) {
                faceUV[0] = new BABYLON.Vector4(0.6, 0.0, 1.0, 1.0); //rear face
                faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.4, 1.0); //front face
                faceUV[2] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //right side
                faceUV[3] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //left side
            }
            else {
                faceUV[0] = new BABYLON.Vector4(0.5, 0.0, 0.75, 1.0); //rear face
                faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.25, 1.0); //front face
                faceUV[2] = new BABYLON.Vector4(0.25, 0, 0.5, 1.0); //right side
                faceUV[3] = new BABYLON.Vector4(0.75, 0, 1.0, 1.0); //left side
            }
            // top 4 and bottom 5 not seen so not set

            /**** World Objects *****/
            const box = BABYLON.MeshBuilder.CreateBox("box", { width: width, faceUV: faceUV, wrap: true });
            box.material = boxMat;
            box.position.y = 0.5;

            return box;
        }

        const buildRoof = (width) => {
            //texture
            const roofMat = new BABYLON.StandardMaterial("roofMat");
            roofMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg");

            const roof = BABYLON.MeshBuilder.CreateCylinder("roof", { diameter: 1.3, height: 1.2, tessellation: 3 });
            roof.material = roofMat;
            roof.scaling.x = 0.75;
            roof.scaling.y = width;
            roof.rotation.z = Math.PI / 2;
            roof.position.y = 1.22;

            return roof;
        }

        window.initFunction = async function () {


            var asyncEngineCreation = async function () {
                try {
                    return createDefaultEngine();
                } catch (e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            startRenderLoop(engine, canvas);
            window.scene = createScene();
        };
        initFunction().then(() => {
            sceneToRender = scene
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>