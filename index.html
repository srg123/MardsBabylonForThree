<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
        var createScene = function () {
            // This creates a basic Babylon Scene object (non-mesh)
            var scene = new BABYLON.Scene(engine);


            //   // This creates and positions a free camera (non-mesh)
            //     var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);

            //     // This targets the camera to scene origin
            //     camera.setTarget(BABYLON.Vector3.Zero());

            var camera = new BABYLON.ArcRotateCamera("camera", BABYLON.Tools.ToRadians(90), BABYLON.Tools.ToRadians(65), 10, BABYLON.Vector3.Zero(), scene);

            // This attaches the camera to the canvas
            camera.attachControl(canvas, true);

            // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // Default intensity is 1. Let's dim the light a small amount
            light.intensity = 0.7;

            // Our built-in 'ground' shape.
            var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 15, height: 15 }, scene);
            let groundMaterial = new BABYLON.StandardMaterial("Ground Material", scene);
            ground.material = groundMaterial;
            //ground.material.diffuseColor = BABYLON.Color3.Red();
            //let groundTexture = new BABYLON.Texture(Assets.textures.checkerboard_basecolor_png.rootUrl, scene);
             let groundTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png");
            ground.material.diffuseTexture = groundTexture;

            BABYLON.SceneLoader.ImportMesh("", Assets.meshes.Yeti.rootUrl, Assets.meshes.Yeti.filename, scene, function (newMeshes) {
                newMeshes[0].scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
                newMeshes[0].position = new BABYLON.Vector3(-1, 0, 3);
                newMeshes[0].rotation = new BABYLON.Vector3(0, Math.PI/12, 0);
            });

             //BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "box.babylon");

        //    BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "both_houses_scene.babylon").then((result) => {
        //    console.log(result);
        //    const house1 = scene.getMeshByName("detached_house");
        //     house1.position.z = 3;
        //    const house2 = result.meshes[2];
        //    house2.position.z = 3;
        //   });

        //    BABYLON.SceneLoader.ImportMeshAsync(["", "semi_house"], "https://assets.babylonjs.com/meshes/", "both_houses_scene.babylon");

        // Load the sound, give it time to load and play it every 3 seconds
          // const bounce = new BABYLON.Sound("bounce", "sounds/bounce.wav", scene);
        //setInterval(() => bounce.play(), 3000);


    

    /**** Materials *****/
    const roofMat = new BABYLON.StandardMaterial("roofMat");
   roofMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg", scene);


   const boxMat = new BABYLON.StandardMaterial("boxMat");
   //boxMat.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/floor.png");
   boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/cubehouse.png")
  


   const roofMat2 = new BABYLON.StandardMaterial("roofMat2");
   roofMat2.diffuseColor = new BABYLON.Color3.Blue();
  

   const roofMat3 = new BABYLON.StandardMaterial("roofMat2");
   roofMat3.diffuseColor = new BABYLON.Color3(0, 1, 0);


    //options parameter to set different images on each side
    const faceUV = [];
    faceUV[0] = new BABYLON.Vector4(0.5, 0.0, 0.75, 1.0); //rear face
    faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.25, 1.0); //front face
    faceUV[2] = new BABYLON.Vector4(0.25, 0, 0.5, 1.0); //right side
    faceUV[3] = new BABYLON.Vector4(0.75, 0, 1.0, 1.0); //left side
    // top 4 and bottom 5 not seen so not set

       /**** World Objects *****/
     const box1 = BABYLON.MeshBuilder.CreateBox("box1", {faceUV: faceUV, wrap: true});
    box1.position.y = 0.5;
    box1.rotation.y = Math.PI / 4;
    //box1.rotation.y = BABYLON.Tools.ToRadians(45);
     box1.material = boxMat;

    const box2 = BABYLON.MeshBuilder.CreateBox("box2", {});
    // box2.scaling.x = 2;
    // box2.scaling.y = 1.5;
    // box2.scaling.z = 3;
    box2.position = new BABYLON.Vector3(-3, 0.5, 0);
    box2.rotation.y = Math.PI / 4;

    const box3 = BABYLON.MeshBuilder.CreateBox("box3", {});
    //box3.scaling = new BABYLON.Vector3(2, 1.5, 3);
    box3.position.x  = 3;
    box3.position.y  = 0.5;
    box3.position.z  = 0;
    box3.rotation.y = Math.PI / 4;


    const roof = BABYLON.MeshBuilder.CreateCylinder("roof", {diameter: 1.3, height: 1.2, tessellation: 3});
    roof.position.y = 1.2;
    roof.scaling.x = 0.75;
    roof.rotation.z = Math.PI / 2;
    roof.rotation.y = Math.PI / 4;

    roof.material = roofMat;


     const roof2 = BABYLON.MeshBuilder.CreateCylinder("roof", {diameter: 1.3, height: 1.2, tessellation: 3});
     roof2.position = new BABYLON.Vector3(-3, 1.2, 0);
    roof2.scaling.x = 0.75;
    roof2.rotation.z = Math.PI / 2;
    roof2.rotation.y = Math.PI / 4;
     roof2.material = roofMat2;


     const roof3 = BABYLON.MeshBuilder.CreateCylinder("roof", {diameter: 1.3, height: 1.2, tessellation: 3});
    roof3.position = new BABYLON.Vector3(3, 1.2, 0);
    roof3.scaling.x = 0.75;
    roof3.rotation.z = Math.PI / 2;
    roof3.rotation.y = Math.PI / 4;

     roof3.material = roofMat3;



     //----------------kaishi

     


     const buildBox = () => {
    const boxMatm = new BABYLON.StandardMaterial("boxMat");
    boxMatm.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/semihouse.png")


    //options parameter to set different images on each side
    const faceUVm = [];
    faceUVm[0] = new BABYLON.Vector4(0.6, 0.0, 1.0, 1.0); //rear face
    faceUVm[1] = new BABYLON.Vector4(0.0, 0.0, 0.4, 1.0); //front face
    faceUVm[2] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //right side
    faceUVm[3] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //left side
    // top 4 and bottom 5 not seen so not set
    

    /**** World Objects *****/
    const boxm = BABYLON.MeshBuilder.CreateBox("boxm", {width: 2, faceUV: faceUVm, wrap: true});
    boxm.material = boxMatm;
    boxm.position.y = 0.5;
    boxm.position.z = -5;

    return boxm;
}


const buildRoof = () => {
     //texture
    const roofMatm = new BABYLON.StandardMaterial("roofMat");
    roofMatm.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg");
   


    const roofm = BABYLON.MeshBuilder.CreateCylinder("roofm", {diameter: 1.3, height: 1.2, tessellation: 3});
    roofm.material = roofMatm;
    roofm.scaling.x = 0.75;
    roofm.scaling.y = 2;
    roofm.rotation.z = Math.PI / 2;
    roofm.position.y = 1.22;
    roofm.position.z = -5;

      return roofm;
    
}

//    const detached_house = buildHouse(1);
//     detached_house.rotation.y = -Math.PI / 16;
//     detached_house.position.x = -6.8;
//     detached_house.position.z = 2.5;

//     const semi_house = buildHouse(2);
//     semi_house .rotation.y = -Math.PI / 16;
//     semi_house.position.x = -4.5;
//     semi_house.position.z = 3;

//     const places = []; //each entry is an array [house type, rotation, x, z]
//     places.push([1, -Math.PI / 16, -6.8, 2.5 ]);
//     places.push([2, -Math.PI / 16, -4.5, 3 ]);
//     places.push([2, -Math.PI / 16, -1.5, 4 ]);
//     places.push([2, -Math.PI / 3, 1.5, 6 ]);
//     places.push([2, 15 * Math.PI / 16, -6.4, -1.5 ]);
//     places.push([1, 15 * Math.PI / 16, -4.1, -1 ]);
//     places.push([2, 15 * Math.PI / 16, -2.1, -0.5 ]);
//     places.push([1, 5 * Math.PI / 4, 0, -1 ]);
//     places.push([1, Math.PI + Math.PI / 2.5, 0.5, -3 ]);
//     places.push([2, Math.PI + Math.PI / 2.1, 0.75, -5 ]);
//     places.push([1, Math.PI + Math.PI / 2.25, 0.75, -7 ]);
//     places.push([2, Math.PI / 1.9, 4.75, -1 ]);
//     places.push([1, Math.PI / 1.95, 4.5, -3 ]);
//     places.push([2, Math.PI / 1.9, 4.75, -5 ]);
//     places.push([1, Math.PI / 1.9, 4.75, -7 ]);
//     places.push([2, -Math.PI / 3, 5.25, 2 ]);
//     places.push([1, -Math.PI / 3, 6, 4 ]);

//     //Create instances from the first two that were built 
//     const houses = [];
//     for (let i = 0; i < places.length; i++) {
//         if (places[i][0] === 1) {
//             houses[i] = detached_house.createInstance("house" + i);
//         }
//         else {
//             houses[i] = semi_house.createInstance("house" + i);
//         }
//         houses[i].rotation.y = places[i][1];
//         houses[i].position.x = places[i][2];
//         houses[i].position.z = places[i][3];
//     }
    


         BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "car.babylon").then(() =>  {
      //car animatiion
      const car = scene.getMeshByName("car");
         car.position = new BABYLON.Vector3(1, 0.5, 2)
        car.scaling = new BABYLON.Vector3(2, 2, 2);
    

      
      const animCar = new BABYLON.Animation("carAnimation", "position.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

      const carKeys = []; 

      carKeys.push({
        frame: 0,
        value: -4
      });


      carKeys.push({
        frame: 150,
        value: 4
      });

      animCar.setKeys(carKeys);

      car.animations = [];
      car.animations.push(animCar);

      scene.beginAnimation(car, 0, 150, true);
      
      //wheel animation
      const wheelRB = scene.getMeshByName("wheelRB");
      const wheelRF = scene.getMeshByName("wheelRF");
      const wheelLB = scene.getMeshByName("wheelLB");
      const wheelLF = scene.getMeshByName("wheelLF");
      
      scene.beginAnimation(wheelRB, 0, 30, true);
      scene.beginAnimation(wheelRF, 0, 30, true);
      scene.beginAnimation(wheelLB, 0, 30, true);
      scene.beginAnimation(wheelLF, 0, 30, true);
    });



      // Dude
    BABYLON.SceneLoader.ImportMeshAsync("him", "/scenes/Dude/", "Dude.babylon", scene).then((result) => {
        var dude = result.meshes[0];
         //dube.position = new BABYLON.Vector3(1, 0.5, -1)
         dude.scaling = new BABYLON.Vector3(0.03, 0.03, 0.03);
         //dube.rotation.x = -Math.PI / 2;
                
        scene.beginAnimation(result.skeletons[0], 0, 100, true, 1.0);



    //         const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 0.25});
    // sphere.position = new BABYLON.Vector3(2, 0, 2);

    //draw lines to form a triangle
    const points = [];
    points.push(new BABYLON.Vector3(2, 0, 2));
    points.push(new BABYLON.Vector3(2, 0, -2));
    points.push(new BABYLON.Vector3(-2, 0, -2));
    points.push(points[0]); //close the triangle;

    BABYLON.MeshBuilder.CreateLines("triangle", {points: points})

    const slide = function (turn, dist) { //after covering dist apply turn
        this.turn = turn;
        this.dist = dist;
    }
    
    const track = [];
    track.push(new slide(Math.PI / 2, 4));
    track.push(new slide(3 * Math.PI / 4, 8));
    track.push(new slide(3 * Math.PI / 4, 8 + 4 * Math.sqrt(2)));

    let distance = 0;
    let step = 0.05;
    let p = 0;

    scene.onBeforeRenderObservable.add(() => {
		dude.movePOV(0, 0, step);
        distance += step;
              
        if (distance > track[p].dist) {        
            dude.rotate(BABYLON.Axis.Y, track[p].turn, BABYLON.Space.LOCAL);
            p +=1;
            p %= track.length;
            if (p === 0) {
                distance = 0;
                dude.position = new BABYLON.Vector3(2, 0, 2); //reset to initial conditions
                dude.rotation = BABYLON.Vector3.Zero();//prevents error accumulation
            }
        }
    });
    });


    


        // const car = buildCar();
        // car.position = new BABYLON.Vector3(1, 0.5, 3)
        // car.scaling = new BABYLON.Vector3(2, 2, 2);
        // car.rotation.x = -Math.PI / 2;


            //Animate the Wheels
    // const animWheel = new BABYLON.Animation("wheelAnimation", "rotation.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

    // const wheelKeys = []; 

    // //At the animation key 0, the value of rotation.y is 0
    // wheelKeys.push({
    //     frame: 0,
    //     value: 0
    // });

    // //At the animation key 30, (after 1 sec since animation fps = 30) the value of rotation.y is 2PI for a complete rotation
    // wheelKeys.push({
    //     frame: 30,
    //     value: 2 * Math.PI
    // });

    // //set the keys
    // animWheel.setKeys(wheelKeys);

    // //Link this animation to a wheel
    // wheelRB.animations = [];
    // wheelRB.animations.push(animWheel);

    // scene.beginAnimation(wheelRB, 0, 30, true);
    //scene.beginAnimation(wheelRF, 0, 30, true);
    // scene.beginAnimation(wheelLB, 0, 30, true);
    // scene.beginAnimation(wheelLF, 0, 30, true);

            return scene;
        };

const buildCar = () => {
    
    //base
    const outline = [
        new BABYLON.Vector3(-0.3, 0, -0.1),
        new BABYLON.Vector3(0.2, 0, -0.1),
    ]

    //curved front
    for (let i = 0; i < 20; i++) {
        outline.push(new BABYLON.Vector3(0.2 * Math.cos(i * Math.PI / 40), 0, 0.2 * Math.sin(i * Math.PI / 40) - 0.1));
    }

    //top
    outline.push(new BABYLON.Vector3(0, 0, 0.1));
    outline.push(new BABYLON.Vector3(-0.3, 0, 0.1));

    //back formed automatically

    //car face UVs
    const faceUV = [];
    faceUV[0] = new BABYLON.Vector4(0, 0.5, 0.38, 1);
    faceUV[1] = new BABYLON.Vector4(0, 0, 1, 0.5);
    faceUV[2] = new BABYLON.Vector4(0.38, 1, 0, 0.5);

    //car material
    const carMat = new BABYLON.StandardMaterial("carMat");
    carMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/car.png");

    const car = BABYLON.MeshBuilder.ExtrudePolygon("car", {shape: outline, depth: 0.2, faceUV: faceUV, wrap: true});
    car.material = carMat;

    //wheel face UVs
    const wheelUV = [];
    wheelUV[0] = new BABYLON.Vector4(0, 0, 1, 1);
    wheelUV[1] = new BABYLON.Vector4(0, 0.5, 0, 0.5);
    wheelUV[2] = new BABYLON.Vector4(0, 0, 1, 1);
    
    //car material
    const wheelMat = new BABYLON.StandardMaterial("wheelMat");
    wheelMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/wheel.png");

    wheelRB = BABYLON.MeshBuilder.CreateCylinder("wheelRB", {diameter: 0.125, height: 0.05, faceUV: wheelUV})
    wheelRB.material = wheelMat;
    wheelRB.parent = car;
    wheelRB.position.z = -0.1;
    wheelRB.position.x = -0.2;
    wheelRB.position.y = 0.035;

    wheelRF = wheelRB.clone("wheelRF");
    wheelRF.position.x = 0.1;

    wheelLB = wheelRB.clone("wheelLB");
    wheelLB.position.y = -0.2 - 0.035;

    wheelLF = wheelRF.clone("wheelLF");
    wheelLF.position.y = -0.2 - 0.035;

    return car;
}


   /******Build Functions***********/
const buildGround = () => {
    //color
    const groundMat = new BABYLON.StandardMaterial("groundMat");
    groundMat.diffuseColor = new BABYLON.Color3(0, 1, 0);

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:15, height:16});
    ground.material = groundMat;
}

const buildHouse = (width) => {
    const box = buildBox(width);
    const roof = buildRoof(width);

    return BABYLON.Mesh.MergeMeshes([box, roof], true, false, null, false, true);
}

const buildBox = (width) => {
    //texture
    const boxMat = new BABYLON.StandardMaterial("boxMat");
    if (width == 2) {
       boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/semihouse.png") 
    }
    else {
        boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/cubehouse.png");   
    }

    //options parameter to set different images on each side
    const faceUV = [];
    if (width == 2) {
        faceUV[0] = new BABYLON.Vector4(0.6, 0.0, 1.0, 1.0); //rear face
        faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.4, 1.0); //front face
        faceUV[2] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //right side
        faceUV[3] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //left side
    }
    else {
        faceUV[0] = new BABYLON.Vector4(0.5, 0.0, 0.75, 1.0); //rear face
        faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.25, 1.0); //front face
        faceUV[2] = new BABYLON.Vector4(0.25, 0, 0.5, 1.0); //right side
        faceUV[3] = new BABYLON.Vector4(0.75, 0, 1.0, 1.0); //left side
    }
    // top 4 and bottom 5 not seen so not set

    /**** World Objects *****/
    const box = BABYLON.MeshBuilder.CreateBox("box", {width: width, faceUV: faceUV, wrap: true});
    box.material = boxMat;
    box.position.y = 0.5;


    

    return box;
}

const buildRoof = (width) => {
    //texture
    const roofMat = new BABYLON.StandardMaterial("roofMat");
    roofMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/roof.jpg");

    const roof = BABYLON.MeshBuilder.CreateCylinder("roof", {diameter: 1.3, height: 1.2, tessellation: 3});
    roof.material = roofMat;
    roof.scaling.x = 0.75;
    roof.scaling.y = width;
    roof.rotation.z = Math.PI / 2;
    roof.position.y = 1.22;

    return roof;
}     
      
        window.initFunction = async function () {


                var asyncEngineCreation = async function () {
                    try {
                        return createDefaultEngine();
                    } catch (e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                    }
                }

                window.engine = await asyncEngineCreation();
                if (!engine) throw 'engine should not be null.';
                startRenderLoop(engine, canvas);
                window.scene = createScene();
            };
            initFunction().then(() => {
                sceneToRender = scene
            });

            // Resize
            window.addEventListener("resize", function () {
                engine.resize();
            });
    </script>
</body>

</html>